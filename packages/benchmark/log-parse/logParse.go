package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"log/slog"
	"os"
	"sync"
)

// Interface fo results of processing a file that can print a summary.
type logSummary interface {
	printSummary()
}

// Summary of processing logs from the workers
type workerLogSummary struct {
	labelMisses   int
	totalRuntime  float64
	totalComplete int
}

// Summary of processing logs from the producer
type producerLogSummary struct {
	totalRequests int
	totalFailed   int
	totalSync     int
}

// Iterate over lines of a log file and send log records to the output channel.
func scanLogFile(fp string, out chan<- *logRecord) {
	defer close(out) // Ensure the output channel is closed when done
	f, err := os.Open(fp)
	if err != nil {
		slog.Error("Failed to open log file", "file", fp, "error", err)
		return
	}
	defer f.Close()
	scanner := bufio.NewScanner(f)
	processed := 0
	for scanner.Scan() {
		l := scanner.Bytes()
		lr := logRecord{}
		jsonErr := json.Unmarshal(l, &lr)
		if jsonErr != nil {
			slog.Error("Failed to parse log line", "line", l, "error", jsonErr)
			continue
		}
		slog.Debug("Processed Record", "level", lr.Level, "message", lr.Message, "time", lr.Time)
		out <- &lr
		processed++
	}
	slog.Info("Completed scanning log file", "file", fp, "records_processed", processed)
}

// Process logs from a worker log file and return a summary
func processWorkerLogs(fp string, wg *sync.WaitGroup) {
	defer wg.Done()
	recs := make(chan *logRecord)
	ps := &workerLogSummary{}
	go scanLogFile(fp, recs)
	for r := range recs {
		if r.isLabelMiss() {
			ps.labelMisses++
		} else if r.taskRuntime() > 0.0 {
			ps.totalComplete++
			ps.totalRuntime += r.taskRuntime()
		}
	}
	if ps.labelMisses == 0 {
		slog.Warn("No label misses found in worker logs", "file", fp)
	}
	ps.printSummary()
}

// Process the logs generated by the producer
func processProducerLogs(fp string, wg *sync.WaitGroup) {
	defer wg.Done()
	recs := make(chan *logRecord)
	go scanLogFile(fp, recs)
	ps := producerLogSummary{
		totalRequests: 0,
		totalFailed:   0,
		totalSync:     0,
	}
	for r := range recs {
		statusCode, endpoint := r.requestResult()
		if statusCode == -1 {
			continue
		}
		ps.totalRequests++
		if statusCode/100 > 2 {
			ps.totalFailed++
		}
		if endpoint == "run-task" {
			ps.totalSync++
		}
	}

	if ps.totalRequests == 0 {
		slog.Warn("No requests found in producer logs", "file", fp)
	}
	ps.printSummary()
}

// Print summary of logs analysis
func (s *workerLogSummary) printSummary() {
	txt := "Worker Log Summary:\n"
	txt += fmt.Sprintf("  Total Label Misses: %d\n", s.labelMisses)
	txt += fmt.Sprintf("  Tasks Completed: %d\n", s.totalComplete)
	if s.totalComplete > 0 {
		avgRuntime := s.totalRuntime / float64(s.totalComplete)
		txt += fmt.Sprintf("  Average Task Runtime: %.4f seconds\n", avgRuntime)
	}
	fmt.Print(txt)
}

func (s *producerLogSummary) printSummary() {
	txt := "Producer Log Summary:\n"
	txt += fmt.Sprintf("  Total Requests: %d\n", s.totalRequests)
	txt += fmt.Sprintf("  Total Failed Requests: %d\n", s.totalFailed)
	txt += fmt.Sprintf("  Total Synchronous Requests: %d\n", s.totalSync)
	txt += fmt.Sprintf("  Total Dispatched Jobs: %d\n", s.totalRequests-s.totalFailed)
	fmt.Print(txt)
}
